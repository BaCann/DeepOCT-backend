# app/auth.py
from fastapi import APIRouter, Depends, HTTPException, Body
from sqlalchemy.orm import Session
from datetime import datetime, timedelta
from jose import jwt, JWTError
from passlib.context import CryptContext
from app import schemas, models, email_utils
from app.database import SessionLocal
from app.config import settings
import random

router = APIRouter()
pwd_context = CryptContext(schemes=["argon2"], deprecated="auto")

# Dependency to get DB session
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# Create JWT token
def create_token(data: dict, expires_delta: timedelta = None):
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=15))
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)

# ----------------- REGISTER -----------------
@router.post("/register")
def register(user: schemas.UserCreate, db: Session = Depends(get_db)):
    db_user = db.query(models.User).filter_by(email=user.email).first()
    if db_user:
        raise HTTPException(status_code=400, detail="Email already registered")
    
    hashed = pwd_context.hash(user.password)
    
    db_user = models.User(
        email=user.email,
        hashed_password=hashed,
        full_name=user.full_name,
        mobile_number=user.mobile_number,
        date_of_birth=user.date_of_birth,
        is_active=True,        
        is_verified=False,     
        # created_at, updated_at auto-generated by SQLAlchemy
    )
    db.add(db_user)
    db.commit()
    
    return {"msg": "User registered successfully"}

# ----------------- LOGIN -----------------
@router.post("/login")
def login(user: schemas.UserLogin, db: Session = Depends(get_db)):
    db_user = db.query(models.User).filter_by(email=user.email).first()
    if not db_user or not pwd_context.verify(user.password, db_user.hashed_password):
        raise HTTPException(status_code=400, detail="Invalid credentials")
    
    
    if not db_user.is_active:
        raise HTTPException(status_code=403, detail="Account has been deactivated")

    access_token = create_token(
        {"sub": db_user.email, "uid": db_user.id, "type": "access"},
        timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    )
    refresh_token = create_token(
        {"sub": db_user.email, "uid": db_user.id, "type": "refresh"},
        timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)
    )

    db_user.refresh_token = refresh_token
    db_user.refresh_token_expire = datetime.utcnow() + timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)
    db.commit()

    return {"access_token": access_token, "refresh_token": refresh_token, "token_type": "bearer"}

# ----------------- RESET PASSWORD (SEND OTP) -----------------
@router.post("/reset-password")
def reset_password(request: schemas.ResetPasswordRequest, db: Session = Depends(get_db)):
    db_user = db.query(models.User).filter_by(email=request.email).first()
    if not db_user:
        raise HTTPException(status_code=404, detail="User not found")
    
    otp = str(random.randint(100000, 999999))
    db_user.otp_code = otp
    db_user.otp_expiration = datetime.utcnow() + timedelta(minutes=1)
    db.commit()
    
    email_utils.send_email_otp(request.email, otp)
    return {"msg": "OTP sent to email"}

# ----------------- RESET PASSWORD (OTP CONFIRM) -----------------
@router.post("/reset-password/otp-confirm")
def reset_confirm(data: schemas.ResetPasswordConfirm, db: Session = Depends(get_db)):
    db_user = db.query(models.User).filter_by(otp_code=data.otp).first()
    if not db_user or datetime.utcnow() > db_user.otp_expiration:
        raise HTTPException(status_code=400, detail="Invalid or expired OTP")

    reset_token = create_token(
        {"sub": db_user.email, "uid": db_user.id, "type": "reset"},
        timedelta(minutes=settings.RESET_TOKEN_EXPIRE_MINUTES)
    )

    db_user.otp_code = None
    db_user.otp_expiration = None
    db.commit()

    return {"reset_token": reset_token, "token_type": "bearer", "msg": "OTP verified successfully"}

# ----------------- CHANGE PASSWORD -----------------
@router.post("/reset-password/change-password")
def change_password(data: schemas.ChangePasswordRequest, db: Session = Depends(get_db)):
    try:
        payload = jwt.decode(data.reset_token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        if payload.get("type") != "reset":
            raise HTTPException(status_code=403, detail="Invalid token type")
        email = payload.get("sub")
    except JWTError:
        raise HTTPException(status_code=403, detail="Invalid or expired token")

    db_user = db.query(models.User).filter_by(email=email).first()
    if not db_user:
        raise HTTPException(status_code=404, detail="User not found")

    db_user.hashed_password = pwd_context.hash(data.new_password)
    db.commit()

    return {"msg": "Password changed successfully"}

# ----------------- REFRESH TOKEN -----------------
@router.post("/refresh-token")
def refresh_token(refresh_token: str = Body(...), db: Session = Depends(get_db)):
    try:
        payload = jwt.decode(refresh_token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        if payload.get("type") != "refresh":
            raise HTTPException(status_code=403, detail="Invalid token type")
        email = payload.get("sub")
    except JWTError:
        raise HTTPException(status_code=403, detail="Invalid or expired refresh token")

    db_user = db.query(models.User).filter_by(email=email).first()
    if not db_user or db_user.refresh_token != refresh_token:
        raise HTTPException(status_code=403, detail="Refresh token not found or mismatched")
    if db_user.refresh_token_expire < datetime.utcnow():
        raise HTTPException(status_code=403, detail="Refresh token expired")

    new_refresh_token = create_token(
        {"sub": db_user.email, "uid": db_user.id, "type": "refresh"},
        timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)
    )
    new_access_token = create_token(
        {"sub": db_user.email, "uid": db_user.id, "type": "access"},
        timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    )

    db_user.refresh_token = new_refresh_token
    db_user.refresh_token_expire = datetime.utcnow() + timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)
    db.commit()

    return {
        "access_token": new_access_token,
        "refresh_token": new_refresh_token,
        "token_type": "bearer"
    }